<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pulsar Java 客户端 · Apache Pulsar</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="You can use a Pulsar Java client to create the Java [producer](#producer), [consumer](#consumer), [readers](#reader) and \[TableView]\](#tableview) of messages and to perform [administrative tasks](/docs/zh-CN/next/admin-api-overview). Java 客户端的当前版本是 **2.9.1**。"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="Pulsar Java 客户端 · Apache Pulsar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pulsar.apache.org/"/><meta property="og:description" content="You can use a Pulsar Java client to create the Java [producer](#producer), [consumer](#consumer), [readers](#reader) and \[TableView]\](#tableview) of messages and to perform [administrative tasks](/docs/zh-CN/next/admin-api-overview). Java 客户端的当前版本是 **2.9.1**。"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://pulsar.apache.org/img/pulsar.svg"/><link rel="shortcut icon" href="/img/pulsar.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://pulsar.apache.org/blog/atom.xml" title="Apache Pulsar Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://pulsar.apache.org/blog/feed.xml" title="Apache Pulsar Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-102219959-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/custom.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/pulsar.svg" alt="Apache Pulsar"/></a><a href="/zh-CN/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/standalone" target="_self">文档</a></li><li class=""><a href="/zh-CN/download" target="_self">下载</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/client-libraries" target="_self">客户端</a></li><li class=""><a href="#restapis" target="_self">REST API</a></li><li class=""><a href="#cli" target="_self">命令行</a></li><li class=""><a href="/blog/" target="_self">博客</a></li><li class=""><a href="#community" target="_self">社区</a></li><li class=""><a href="#apache" target="_self">Apache</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/next/client-libraries-java">English</a></li><li><a href="/docs/ja/next/client-libraries-java">日本語</a></li><li><a href="/docs/fr/next/client-libraries-java">Français</a></li><li><a href="/docs/ko/next/client-libraries-java">한국어</a></li><li><a href="/docs/zh-TW/next/client-libraries-java">繁體中文</a></li><li><a href="https://crowdin.com/project/apache-pulsar" target="_blank" rel="noreferrer noopener">参与翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>客户端库</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Get Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone">本地运行 Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone-docker">在 Docker 中运行 Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/kubernetes-helm">在 Kubernetes 中运行 Pulsar</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">概念和架构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-messaging">消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-architecture-overview">架构</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-clients">客户端</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-replication">跨机房复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multi-tenancy">多租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-authentication">认证和授权</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-topic-compaction">消息压缩</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-proxy-sni-routing">Pulsar Proxy 支持 SNI 路由</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multiple-advertised-listeners">配置 Advertised 监听器</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Schema</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-get-started">开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-understand">理解 schema</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-evolution-compatibility">Schema 演化和兼容</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-manage">管理 Schema</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-runtime">设置：配置 Pulsar Functions 运行时</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-worker">设置：Pulsar Functions Worker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-develop">操作：开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-package">如何打包</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-debug">操作：调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-deploy">操作：部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-cli">参考：命令</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/window-functions-context">窗口函数：上下文</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar IO</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-quickstart">开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-use">使用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-debug">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-connectors">内置 connector</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cdc">CDC connector</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-develop">开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cli">CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar SQL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-getting-started">查询数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-deployment-configurations">配置和部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-rest-api">REST API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">层级存储</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-aws">亚马逊 AWS S3 offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-gcs">GCS offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-filesystem">Filesystem offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-azure">Azure BlobStore offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-aliyun">阿里云 OSS offloader</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">事务</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-why">为什么需要事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-what">什么是事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-how">事务运行原理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-use">如何使用事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-monitor">如何监控事务？</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Kubernetes (Helm)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-prepare">准备</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-install">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-deploy">部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-upgrade">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-tools">所需工具</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">部署</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-aws">Amazon Web Services (Aws)</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-kubernetes">Kubernetes</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal">裸机</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal-multi-cluster">裸机多集群部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-docker">Docker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-monitoring">Monitor</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">系统管理</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-zk-bk">ZooKeeper 和 BookKeeper</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-geo">跨地域复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-pulsar-manager">Pulsar Manager</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-stats">Pulsar 统计数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-load-balance">负载均衡</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-proxy">Pulsar 代理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-upgrade">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-isolation">Pulsar 隔离</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">安全</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-transport">使用TLS进行传输加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-authentication">使用TLS进行认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-keystore">使用 TLS 配置KeyStore</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-jwt">使用 JWT 认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-athenz">使用 Athenz 验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-kerberos">使用 Kerberos 进行身份验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-oauth2">使用 OAuth 2.0 访问令牌进行身份验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-authorization">授权和ACL</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-encryption">端到端加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-extending">扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-bouncy-castle">Bouncy Castle Providers</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">性能</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/performance-pulsar-perf">Pulsar Perf 性能测试</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">客户端库</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries">概述</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/next/client-libraries-java">Java</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-go">Go</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-python">Python</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-cpp">C++</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-node">Node.js
</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-websocket">WebSocket</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-dotnet">C#</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-rest">REST</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Admin API</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-clusters">集群</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-tenants">租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-brokers">Brokers</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-namespaces">命名空间</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-permissions">权限管理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-topics">Topic</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-functions">Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-packages">Package</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">适配器</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-kafka">Kafka 客户端封装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-spark">Apache Spark</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-storm">Apache Storm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考手册</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-compaction">Topic compaction</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-deduplication">消息去重</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-non-persistent">非持久化消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-retention-expiry">消息保留和过期</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-encryption">加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-message-queue">消息队列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-bookkeepermetadata">BookKeeper Ledger 元数据</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">开发</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-tools">模拟工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-binary-protocol">二进制协议</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-load-manager">模块化负载管理器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-plugin">Plugin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-terminology">术语</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-cli-tools">Pulsar 命令行工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-configuration">Pulsar configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-metrics">Pulsar Metrics</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/apache-pulsar/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Pulsar Java 客户端</h1></header><article><div><span><p>You can use a Pulsar Java client to create the Java <a href="#producer">producer</a>, <a href="#consumer">consumer</a>, <a href="#reader">readers</a> and [TableView]](#tableview) of messages and to perform <a href="/docs/zh-CN/next/admin-api-overview">administrative tasks</a>. Java 客户端的当前版本是 <strong>2.9.1</strong>。</p>
<p>All the methods in <a href="#producer">producer</a>, <a href="#consumer">consumer</a>, <a href="#reader">readers</a> and [TableView]](#tableview) of a Java client are thread-safe.</p>
<p>Pulsar 客户端的Javadoc 分为如下两个包：</p>
<table>
<thead>
<tr><th style="text-align:left">包</th><th style="text-align:left">说明</th><th style="text-align:left">Maven Artifact</th></tr>
</thead>
<tbody>
<tr><td style="text-align:left"><a href="/api/client/2.9.0-SNAPSHOT"><code>org.apache.pulsar.client.api</code></a></td><td style="text-align:left">生产者和消费者 API</td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client:2.9.1</a></td></tr>
<tr><td style="text-align:left"><a href="/api/admin/2.9.0-SNAPSHOT"><code>org.apache.pulsar.client.admin</code></a></td><td style="text-align:left">Java <a href="/docs/zh-CN/next/admin-api-overview">管理API</a></td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-admin%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client-admin:2.9.1</a></td></tr>
<tr><td style="text-align:left"><code>org.apache.pulsar.client.all</code></td><td style="text-align:left">包含 <code>pulsar-client</code> 和 <code>pulsar-client-admin</code>。</td></tr>
</tbody>
</table>
<p><code>pulsar-client</code> 和 <code>pulsar-client-admin</code> 二者都是被 shade 的包，并且它们是独立地 shade 依赖项的。 因此，同时使用 <code>pulsar-client</code> 和 <code>pulsar-client-admin</code> 的应用程序会有冗余的 shade 类。 如果您引入了新的依赖项，但忘记更新 shade 规则，就会引起问题。<br>
在这种情况下，可以使用 <code>pulsar-client-all</code>，它只对依赖项 shade 一次，并减少了依赖项的大小。 | <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-all%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client-all:2.9.1</a>     |</p>
<p>本文档仅关注 Pulsar 主题消息的生产和消费的客户端 API。 如果想使用Java版本的管理客户端，可以查看 <a href="/docs/zh-CN/next/admin-api-overview">Pulsar 管理接口</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="安装"></a><a href="#安装" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装</h2>
<p>最新版本的Pulsar Java 客户端库可从 <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.9.1%7Cjar">Maven中央仓库</a> 安装。 要使用最新版本, 请将 <code>pulsar-client</code> 库添加到构建配置中。</p>
<h3><a class="anchor" aria-hidden="true" id="maven"></a><a href="#maven" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maven</h3>
<p>如果你使用Maven，添加下面信息到 <code>pom.xml</code> 文件中。</p>
<pre><code class="hljs css language-xml"><span class="hljs-comment">&lt;!-- 在你的 &lt;properties&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pulsar.version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">pulsar.version</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 在你的 &lt;dependencies&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.pulsar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pulsar-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${pulsar.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="gradle"></a><a href="#gradle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gradle</h3>
<p>如果你使用Gradle，添加下面内容到<code>build.gradle</code> 文件。</p>
<pre><code class="hljs css language-groovy"><span class="hljs-keyword">def</span> pulsarVersion = <span class="hljs-string">'2.9.1'</span>

dependencies {
    compile <span class="hljs-string">group:</span> <span class="hljs-string">'org.apache.pulsar'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'pulsar-client'</span>, <span class="hljs-string">version:</span> pulsarVersion
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="连接-url"></a><a href="#连接-url" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>连接 URL</h2>
<p>要使用客户端连接到 Pulsar，你需要指定<a href="/docs/zh-CN/next/develop-binary-protocol">Pulsar 协议</a>URL。</p>
<p>可以给特定集群分配 Pulsar 协议格式的 URL，并使用 <code>Pulsar</code> Scheme。默认端口号为 <code>6650</code> 。下面是一个 <code>localhost</code> 例子。</p>
<pre><code class="hljs css language-http">pulsar://localhost:6650
</code></pre>
<p>If you have multiple brokers, the URL is as follows.</p>
<pre><code class="hljs css language-http">pulsar://localhost:6550,localhost:6651,localhost:6652
</code></pre>
<p>A URL for a production Pulsar cluster is as follows.</p>
<pre><code class="hljs css language-http">pulsar://pulsar.us-west.example.com:6650
</code></pre>
<p>If you use <a href="/docs/zh-CN/next/security-tls-authentication">TLS</a> authentication, the URL is as follows.</p>
<pre><code class="hljs css language-http">pulsar+ssl://pulsar.us-west.example.com:6651
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="client"></a><a href="#client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Client</h2>
<p>You can instantiate a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 object using just a URL for the target Pulsar <a href="/docs/zh-CN/next/reference-terminology#cluster">cluster</a> like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650"</span>)
        .build();
</code></pre>
<p>If you have multiple brokers, you can initiate a PulsarClient like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650,localhost:6651,localhost:6652"</span>)
        .build();
</code></pre>
<blockquote>
<h3><a class="anchor" aria-hidden="true" id="默认的broker-url是单机集群"></a><a href="#默认的broker-url是单机集群" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认的broker URL是单机集群。</h3>
<p>如果运行的是 <a href="/docs/zh-CN/next/standalone">standalone </a> 模式的集群，则默认可以通过 <code>pulsar://localhost:6650</code> 这个 URL 来访问 broker。</p>
</blockquote>
<p>在创建客户端时，可以采用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 可用的参数如下。</p>
<p>| 名称 | 类型 |</p>
<div style="width:260px">
  说明
</div>
<p>| 默认值 |---|---|---|--- <code>serviceUrl</code> | String | Pulsar服务的服务 URL 提供者 | 无 <code>authPluginClassName</code> | String | 认证插件的名称 | 无 <code>authParams</code> | String | 认证插件的参数</p>
<p><strong>例如</strong>  <br>
key1:val1,key2:val2 | 无 <code>operationTimeoutMs</code> | long | <code>operationTimeoutMs</code> | 操作超时时长（毫秒） | 30000 <code>statsIntervalSeconds</code> | long | 每个统计信息之间的时间间隔（秒）</p>
<p>当 <code>statsInterval</code>为正数时统计信息才被激活。</p>
<p>请将 <code>statsIntervalSeconds</code> 设置为至少 1 秒。 | 60 <code>numIoThreads</code> | int | 用于处理 broker 连接的线程数 | 1 <code>numListenerThreads</code> | int | 用于处理消息监听器的线程数。 所有的消费者和读者共享监听器线程池，并使用 “监听器”模式获取消息。 对于某个消费者来说，为了保证有序性，总在同一线程中调用监听器。 如果想用多线程处理单个 topic，需要采用 <a href="https://pulsar.apache.org/docs/en/next/concepts-messaging/#shared"><code>shared</code></a> 订阅模式，并为这个订阅创建多个消费者。 这样不能保证有序。| 1 <code>useTcpNoDelay</code>| boolean | 是否在连接上使用 TCP 无延迟标志来禁用 Nagle 算法 | true <code>useTls</code> | boolean | 是否在连接上使用 TLS 加密 | false <code>tlsTrustCertsFilePath</code> | string | 受信 TLS 证书文件的路径 | 无 <code>tlsAllowInsecureConnection</code> | boolean | Pulsar 客户端是否接受来自 broker 的非受信 TLS 证书 | false <code>tlsHostnameVerificationEnable</code> | boolean | 是否启用 TLS 主机名验证 | false <code>concurrentLookupRequest</code> | int | 每个 Broker 连接上允许发送的并发查找请求数，以防止 Broker 过载 | 5000 <code>maxLookupRequest</code> | int | 每个 Broker 连接上允许的最大查找请求数，以防止Broker过载 | 50000 <code>maxNumberOfRejectedRequestPerConnection</code> | int | 在当前连接关闭且客户端创建新连接以连接到另一个 broker 之后的特定时间段 (30秒) 内，broker 请求被拒绝的最大次数 | 50 <code>keepAliveIntervalSeconds</code> | int | 每个客户端 broker 连接的保活间隔的秒数 | 30 <code>connectionTimeoutMs</code> | int | 与 broker 建立连接的等待超时时间</p>
<p>如果持续时间过去了还没有收到 broker 响应，则连接尝试将被丢弃 | 10000 <code>requestTimeoutMs</code> | int | 完成请求的最长持续时间 | 60000 <code>defaultBackoffIntervalNanos</code> | int | Backoff 间隔的默认持续时间 | TimeUnit.MILLISECONDS.toNanos(100); <code>maxBackoffIntervalNanos</code> | long |Backoff 间隔的最大持续时间 | TimeUnit.SECONDS.toNanos(30) <code>socks5ProxyAddress</code> | SocketAddress | SOCKS5 代理地址 | 无 <code>socks5ProxyUsername</code> | string | SOCKS5 代理用户账号 | 无 <code>socks5ProxyPassword</code> | string | SOCKS5 代理用户密码 | 无</p>
<p>Check out the Javadoc for the <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 class for a full list of configurable parameters.</p>
<blockquote>
<p>除了客户端级别的配置，你还可以使用特定于 <a href="#configure-producer">生产者</a>和<a href="#configure-consumer">消费者</a>的配置，下面的章节将会讲述。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="客户端内存分配器配置"></a><a href="#客户端内存分配器配置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端内存分配器配置</h3>
<p>您可以通过 Java 属性来设置客户端内存分配器的配置。</p>
<p>| 属性 | 类型 |</p>
<div>
  说明
</div>
<p>| 默认值 | 可用值 |---|---|---|---|----- <code>pulsar.allocator.pooled</code> | String | 如果设置为 true <code>true</code>，则客户端使用直接内存池。 </br> 如果设置为 false <code>false</code>，则客户端使用堆内存，而不是内存池 | true |</p>
<ul>
<li><p>true</p></li>
<li><p>false
<code>pulsar.allocator.exit_on_oom</code> | String | 当 OOM 出现的时候是否直接退出 JVM | false |</p></li>
<li><p>true</p></li>
<li><p>false
<code>pulsar.allocator.leak_detection</code> | String | Pulsar 服务的服务 URL 提供者 | Disabled |</p></li>
<li><p>Disabled</p></li>
<li><p>Simple</p></li>
<li><p>Advanced</p></li>
<li><p>Paranoid
<code>pulsar.allocator.out_of_memory_policy</code> | String | 当出现 OOM 时，客户端是抛出异常，还是退回使用堆 | FallbackToHeap |</p></li>
<li><p>ThrowException</p></li>
<li><p>FallbackToHeap</p></li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="hljs">-Dpulsar.allocator.pooled=true
-Dpulsar.allocator.exit_on_oom=false
-Dpulsar.allocator.leak_detection=Disabled
-Dpulsar.allocator.out_of_memory_policy=ThrowException
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="生产者producer"></a><a href="#生产者producer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产者（Producer）</h2>
<p>在Pulsar中，生产者写消息到主题中。 一旦你实例化一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
客户端对象(在<a href="#client-configuration">如上</a>z章节)，你可以创建一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/Producer">Producer</a>
生产者用于特定的<a href="/docs/zh-CN/next/reference-terminology#topic">主题</a>。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();

<span class="hljs-comment">// 然后你就可以发送消息到指定的broker 和topic上：</span>
producer.send(<span class="hljs-string">"My message"</span>.getBytes());
</code></pre>
<p>默认情况下，生产者生产的消息为字节数组类型。可以通过指定消息的<a href="#schema">schema</a> 来生产不同类型的消息。</p>
<pre><code class="hljs css language-java">Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();
stringProducer.send(<span class="hljs-string">"My message"</span>);
</code></pre>
<blockquote>
<p>当不再需要生产者、消费者和客户端时，请确保将其关闭。</p>
<pre><code class="hljs css language-java">producer.close();
consumer.close();
client.close();
</code></pre>
<p>关闭操作也可以是异步的：</p>
<pre><code class="hljs css language-java">producer.closeAsync()
   .thenRun(() -&gt; System.out.println(<span class="hljs-string">"Producer closed"</span>))
   .exceptionally((ex) -&gt; {
       System.err.println(<span class="hljs-string">"Failed to close producer: "</span> + ex);
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   });
</code></pre>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="配置producer生产者"></a><a href="#配置producer生产者" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置Producer（生产者）</h3>
<p>如上例，在实例化 <code>Producer</code> 对象时只指定主题名称的话，生产者将使用默认配置。</p>
<p>创建生产者时可以用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 的可用参数如下所示。</p>
<p>名称 | 类型 |</p>
<div style="width:300px">
  说明
</div>| 默认值 |\---|\---|\---|\--- 
<p><code>topicName</code>| string | 主题名称 | null | <code>producerName</code>| string | 生产者名称 | null <code>sendTimeoutMs</code>| long | 消息发送的超时时间，单位是毫秒。<br>
如果在超时时间之内消息未被服务端确认 <code>sendTimeout</code> 就会产生错误。| 30000 <code>blockIfQueueFull</code>| boolean | 如果设置为 true <code>true</code>，当传出消息队列已满时， <code>Send</code> and <code>SendAsync</code> 方法会阻塞生产者，而不是失败或抛出错误。<br>
If it is set to <code>false</code>，当传出消息队列已满时， <code>Send</code> and <code>SendAsync</code> 方法会失败，并且 <code>ProducerQueueIsFullError</code> 异常会被抛出。</p>
<p>这个 <code>MaxPendingMessages</code> 参数决定传出消息队列的大小。| false <code>maxPendingMessages</code>| int | 保存待处理消息的队列的最大长度。</p>
<p>例如，一个消息正在等待接收 broker 的确认 <a href="/docs/zh-CN/next/reference-terminology#broker">broker</a>.</p>
<p>默认情况下，当队列已满时，所有调用 <code>Send</code> and <code>SendAsync</code> 方法将会失败， <strong>除非</strong> 你设置 <code>BlockIfQueueFull</code> 为 <code>true</code>。| 1000 <code>maxPendingMessagesAcrossPartitions</code>| int | 跨分区待处理消息的最大数量。</p>
<p>如果待处理消息的总数超过了所配置的值，则使用该设置降低每个分区的最大待处理消息数 ({@link #setMaxPendingMessages(int)}) | 50000 <code>messageRoutingMode</code>| MessageRoutingMode | 分区主题生产者的消息路由逻辑 <a href="/docs/zh-CN/next/concepts-architecture-overview#partitioned-topics"> </a>.<br>
仅当没有设置消息 key 时才应用这个逻辑。<br>
可用选项如下所示：</p>
<ul>
<li><code>pulsar.RoundRobinDistribution</code>: round robin</li>
<li><code>pulsar.UseSinglePartition</code>: publish all messages to a single partition</li>
<li><code>pulsar.CustomPartition</code>：自定义的分区 scheme |<code>pulsar.RoundRobinDistribution</code>
<code>hashingScheme</code>| HashingScheme | 生产消息时用来决定分区的哈希函数 (<strong>仅适用于分区主题</strong>).<br>
可用选项如下所示：</li>
</ul>
<ul>
<li><code>pulsar.JavastringHash</code>：等同于 Java 中的 <code>String.hashCode()</code></li>
<li><code>pulsar.Murmur3_32Hash</code>: applies the <a href="https://en.wikipedia.org/wiki/MurmurHash">Murmur3</a> hashing function</li>
<li><code>pulsar.BoostHash</code>：应用 C++ <a href="https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html">Boost</a> 库中的哈希函数 |
<code>HashingScheme.JavastringHash</code> <code>cryptoFailureAction</code>| ProducerCryptoFailureAction | 当加密失败时生产者需要采取的行动。</li>
</ul>
<ul>
<li><p><strong>FAIL</strong>：如果加密失败，则未加密的消息将会发送失败。</p></li>
<li><p><strong>SEND</strong>：如果加密失败，则未加密的消息将会发送成功。 |
<code>ProducerCryptoFailureAction.FAIL</code> <code>batchingMaxPublishDelayMicros</code>| long | 发送消息时的批处理时间。| TimeUnit.MILLISECONDS.toMicros(1) <code>batchingMaxMessages</code> | int | 一批消息中允许的最大消息个数。| 1000 <code>batchingEnabled</code>| boolean | 启用消息批处理。| true <code>compressionType</code>| CompressionType | 生产者使用的消息数据压缩类型。<br>
可用选项：</p></li>
<li><p><a href="https://github.com/lz4/lz4"><code>LZ4</code></a></p></li>
<li><p><a href="https://zlib.net/"><code>ZLIB</code></a></p>
<ul>
<li><a href="https://facebook.github.io/zstd/"><code>ZSTD</code></a></li>
<li><a href="https://google.github.io/snappy/"><code>SNAPPY</code></a>| 无压缩</p>
You can configure parameters if you do not want to use the default configuration.</li>
</ul>
<p>如需查看所有参数，可参考 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/ProducerBuilder">ProducerBuilder</a>
 类的 Javadoc 文档。下面是一个示例。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
    .topic(<span class="hljs-string">"my-topic"</span>)
    .batchingMaxPublishDelay(<span class="hljs-number">10</span>, TimeUnit.MILLISECONDS)
    .sendTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS)
    .blockIfQueueFull(<span class="hljs-keyword">true</span>)
    .create();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="消息路由"></a><a href="#消息路由" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息路由</h3>
<p>当使用分区主题时，当你使用生产者发布消息时你可以指定路由模式。 关于如何使用 Java 客户端指定路由模式的更多内容，可参考 <a href="/docs/zh-CN/next/cookbooks-partitioned">Partitioned Topics cookbook</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="异步发送"></a><a href="#异步发送" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步发送</h3>
<p>You can publish messages <a href="/docs/zh-CN/next/concepts-messaging#send-modes">asynchronously</a> using the Java client. With async send, the producer puts the message in a blocking queue and returns it immediately. Then the client library sends the message to the broker in the background. If the queue is full (max size configurable), the producer is blocked or fails immediately when calling the API, depending on arguments passed to the producer.</p>
<p>The following is an example.</p>
<pre><code class="hljs css language-java">producer.sendAsync(<span class="hljs-string">"my-async-message"</span>.getBytes()).thenAccept(msgId -&gt; {
    System.out.println(<span class="hljs-string">"Message with ID "</span> + msgId + <span class="hljs-string">" successfully sent"</span>);
});
</code></pre>
<p>As you can see from the example above, async send operations return a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/MessageId">MessageId</a>
 wrapped in a <a href="http://www.baeldung.com/java-completablefuture"><code>CompletableFuture</code></a>.</p>
<h3><a class="anchor" aria-hidden="true" id="配置消息"></a><a href="#配置消息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置消息</h3>
<p>In addition to a value, you can set additional items on a given message:</p>
<pre><code class="hljs css language-java">producer.newMessage()
    .key(<span class="hljs-string">"my-message-key"</span>)
    .value(<span class="hljs-string">"my-async-message"</span>.getBytes())
    .property(<span class="hljs-string">"my-key"</span>, <span class="hljs-string">"my-value"</span>)
    .property(<span class="hljs-string">"my-other-key"</span>, <span class="hljs-string">"my-other-value"</span>)
    .send();
</code></pre>
<p>You can terminate the builder chain with <code>sendAsync()</code> and get a future return.</p>
<h2><a class="anchor" aria-hidden="true" id="消费者consumer"></a><a href="#消费者consumer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消费者（Consumer）</h2>
<p>在Pulsar中，消费者订阅topic主题并处理生产者发布到这些主题的消息。 你可以首先实例化一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
对象并传递给他一个borker(<a href="#client-configuration">如上所示</a>) URL来实例化一个<a href="/docs/zh-CN/next/reference-terminology#consumer">消费者</a>。</p>
<p>当 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 对象实例化完成后，您可以创建一个 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/Consumer">Consumer</a>
 对象，并指定一个 <a href="/docs/zh-CN/next/reference-terminology#topic">主题</a> 和 <a href="/docs/zh-CN/next/concepts-messaging#subscription-types">订阅</a>.</p>
<pre><code class="hljs css language-java">Consumer consumer = client.newConsumer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .subscriptionName(<span class="hljs-string">"my-subscription"</span>)
        .subscribe();
</code></pre>
<p>The <code>subscribe</code> method will auto subscribe the consumer to the specified topic and subscription. 一种让消费者监听主题的方法是使用<code>while</code>循环。 In this example loop, the consumer listens for messages, prints the contents of any received message, and then <a href="/docs/zh-CN/next/reference-terminology#acknowledgment-ack">acknowledges</a> that the message has been processed. If the processing logic fails, you can use <a href="/docs/zh-CN/next/reference-terminology#acknowledgment-ack">negative acknowledgement</a> to redeliver the message later.</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
  <span class="hljs-comment">// Wait for a message</span>
  Message msg = consumer.receive();

  <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Do something with the message</span>
      System.out.println(<span class="hljs-string">"Message received: "</span> + <span class="hljs-keyword">new</span> String(msg.getData()));

      <span class="hljs-comment">// Acknowledge the message so that it can be deleted by the message broker</span>
      consumer.acknowledge(msg);
  } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-comment">// Message failed to process, redeliver later</span>
      consumer.negativeAcknowledge(msg);
  }
}
</code></pre>
<p>If you don't want to block your main thread and rather listen constantly for new messages, consider using a <code>MessageListener</code>.</p>
<pre><code class="hljs css language-java">MessageListener myMessageListener = (consumer, msg) -&gt; {
  <span class="hljs-keyword">try</span> {
      System.out.println(<span class="hljs-string">"Message received: "</span> + <span class="hljs-keyword">new</span> String(msg.getData()));
      consumer.acknowledge(msg);
  } <span class="hljs-keyword">catch</span> (Exception e) {
      consumer.negativeAcknowledge(msg);
  }
}

Consumer consumer = client.newConsumer()
     .topic(<span class="hljs-string">"my-topic"</span>)
     .subscriptionName(<span class="hljs-string">"my-subscription"</span>)
     .messageListener(myMessageListener)
     .subscribe();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="配置消费者"></a><a href="#配置消费者" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置消费者</h3>
<p>If you instantiate a <code>Consumer</code> object by specifying only a topic and subscription name as in the example above, the consumer uses the default configuration.</p>
<p>当您创建消费者时，可以采用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 可用的参数如下。</p>
<p>名称 | 类型 |</p>
<p><div style="width:300px">
说明
</div>
| 默认值 |---|---|---|--- <code>topicNames</code>| Set<String>| 主题名称 | Sets.newTreeSet() <code>topicsPattern</code>| Pattern | 主题模式 | 无 <code>subscriptionName</code>| String | 订阅名称 | 无 <code>subscriptionType</code>| SubscriptionType | 订阅模式<br>
共有四种订阅模式：</p>
<ul>
<li>Exclusive</li>
<li>Failover（灾备）</li>
<li>Shared（共享）</li>
<li>Key_Shared| SubscriptionType.Exclusive
<code>receiverQueueSize</code> | int | 消费者接收队列的大小。</li>
</ul>
<p>例如，在应用程序调用 Receive 方法之前消费者累积的消息数量。 <code></code>.</p>
<p>设置为高于默认值会提高消费者吞吐量，但会增加内存开销。| 1000 <code>acknowledgementsGroupTimeMicros</code>| long | 将消费者确认按指定时间分组。</p>
<p>默认情况下，消费者使用 100ms 分组时间向 broker 发送确认。</p>
<p>如果分组时间设置为 0，则会立即发送确认。</p>
<p>分组时间越长则越有效率，而代价是消息失败后的重传次数会略有增加。| TimeUnit.MILLISECONDS.toMicros(100) <code>negativeAckRedeliveryDelayMicros</code>| long | 在重新发送处理失败的消息之前的延迟等待时间。</p>
<p>当应用程序使用 {@link Consumer#negativeAcknowledge(Message)}，失败的消息会在一个固定的超时时间之后重传。| TimeUnit.MINUTES.toMicros(1) <code>maxTotalReceiverQueueSizeAcrossPartitions</code>| int | 跨分区的接收队列最大总长度。</p>
<p>如果接收队列总长度超过此值，则此设置会降低单个分区的接收队列长度。| 50000 <code>consumerName</code>| String | 消费者名称 | null <code>ackTimeoutMillis</code>| long | 未确认消息的超时时间 | 0 <code>tickDurationMillis</code>| ack-timeout 重传粒度。</p>
<p>使用更高的 <code>tickDurationMillis</code> 在将确认超时设置为较大值时 (例如1小时)，增大 tickDurationMillis 会降低追踪消息是的内存开销。|1000 <code>priorityLevel</code>| int | 在共享订阅模式下，broker 分发消息时给予消费者的优先级别。</p>
<p>Broker 按照优先级降序排序。例如 0 表示最大优先级，其次是 1，2……</p>
<p>在共享订阅模式下，broker <strong>优先将消息分发给优先级最高的消费者，只要他们有许可。</strong>否则，broker 会分发给下一个优先级别的消费者。</p>
<p><strong>示例 1</strong>  <br>
如果一个订阅有消费者 consumerA <code>priorityLevel</code> 为0，另一个消费者 consumerB <code>priorityLevel</code> 为 1，则 broker <strong>只会向 consumerA 分发消息，直到其用完许可，</strong> 然后才会开始向 consumerB 分发消息。</p>
<p><strong>示例 2</strong>  <br>
消费者，优先级别，许可<br>
C1, 0, 2<br>
C2, 0, 1<br>
C3, 0, 1<br>
C4, 1, 2<br>
C5, 1, 1</p>
<p>Broker 分发消息给消费者的顺序是：C1, C2, C3, C1, C4, C5, C4。| 0 <code>cryptoFailureAction</code>| ConsumerCryptoFailureAction | 当接收到无法解密的消息时，消费者应该采取的行动。</p></li>
</ul>
<pre><code class="hljs">* **FAIL**：这是在加密成功之前对于失败消息采取的默认选项。
* **DISCARD**：静默地确认消息，而不将消息分发给应用程序。
* **CONSUME**：向应用程序分发加密的消息。而由应用程序负责解密消息。
  
消息解压失败。   
  
如果消息包含批处理消息，则客户端无法在 batch 中检索单条消息。  
  
分发的加密消息包含 {@link EncryptionContext}，其中包含加密和压缩信息，应用程序可以利用这些信息解密消息载荷。| ConsumerCryptoFailureAction.FAIL&lt;/li&gt; `properties`| SortedMap&lt;String, String&gt; | 此消费者的名称或值属性。  
  
`properties` 是附加到消费者上的应用程序定义的元数据。   
  
获取主题统计信息时，可以将此元数据与消费者统计信息相关联，以便于识别。| new TreeMap&lt;&gt;() `readCompacted`| boolean | 如果启用 `readCompacted`，则消费者从压缩主题中读取消息，而不是读取主题的完整消息 backlog。  
  
消费者只能看到压缩主题中每个 key 的最新值，直到压缩 backlog 时主题消息中对应的位点。 超过这一位点，消息照常发送。  
  
仅启用 `readCompacted` 在持久化主题的订阅上，持久化主题仅有单个活跃消费者 (类似故障或独占订阅模式)。   
  
如果试图在非持久化主题或者共享订阅上开启该功能，则会导致订阅调用抛出 `PulsarClientException`。|false `subscriptionInitialPosition`| SubscriptionInitialPosition | 首次订阅主题时游标的初始位置。| SubscriptionInitialPosition.Latest `patternAutoDiscoveryPeriod`| int | 当主题消费者使用模式匹配时，自动发现主题的时间周期。  
  
默认值和最小值都为 1 分钟。| 1 `regexSubscriptionMode`| RegexSubscriptionMode | 当使用正则表达式订阅主题时，可以选择特定类型的主题。  
  


* **PersistentOnly**：只订阅持久化主题。
* **NonPersistentOnly**：只订阅非持久化主题。
* **AllTopics**：同时订阅持久化和非持久化主题。|RegexSubscriptionMode.PersistentOnly 
`deadLetterPolicy`| DeadLetterPolicy | 消费者的死信策略。  
  
默认情况下，一些消息可能会被多次重传，甚至可能一直重传。  
  
利用死信机制，可以限制消息的最大重传次数。 **当超过最大重传次数时，消息会被发送到死信主题并自动确认。**.  
  
如果要启动死信机制，可以配置 `deadLetterPolicy`.  
  
**示例**  
  
`client.newConsumer()&lt;br /&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10).build())&lt;br /&gt;.subscribe();`  
  
默认的死信主题名称是 `{TopicName}-{Subscription}-DLQ`.  
  
设置自定义的死信主题名称：  
`client.newConsumer()&lt;br /&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10)&lt;br /&gt;.deadLetterTopic(&quot;your-topic-name&quot;).build())&lt;br /&gt;.subscribe();`  
  
如果设置了死信策略，但没有指定 `ackTimeoutMillis`，则可以将确认超时时间设置为 30000 毫秒。| 无 `autoUpdatePartitions`| boolean | 如果 `autoUpdatePartitions` 被启动，则消费者会自动订阅新增分区。  
  
**Note**：仅适用于分区消费者。| true `replicateSubscriptionState`| boolean | 如果 `replicateSubscriptionState`  被启动，则订阅状态会被复制到跨地域复制的集群中。| false `negativeAckRedeliveryBackoff`|RedeliveryBackoff|Interface for custom message is negativeAcked policy. You can specify `RedeliveryBackoff` 为一个消费者。| `MultiplierRedeliveryBackoff` `ackTimeoutRedeliveryBackoff`|RedeliveryBackoff|Interface for custom message is ackTimeout policy. You can specify `RedeliveryBackoff` 为一个消费者。| `MultiplierRedeliveryBackoff`

You can configure parameters if you do not want to use the default configuration. For a full list, see the Javadoc for the {@inject: javadoc:ConsumerBuilder:/client/org/apache/pulsar/client/api/ConsumerBuilder} class.

The following is an example.

```java
Consumer consumer = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .ackTimeout(10, TimeUnit.SECONDS)
        .subscriptionType(SubscriptionType.Exclusive)
        .subscribe();
```

### 异步接收

The `receive` method receives messages synchronously (the consumer process is blocked until a message is available). You can also use [async receive](/docs/zh-CN/next/concepts-messaging#receive-modes), which returns a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) object immediately once a new message is available.

The following is an example.

```java
CompletableFuture&lt;Message&gt; asyncMessage = consumer.receiveAsync();
```

Async receive operations return a {@inject: javadoc:Message:/client/org/apache/pulsar/client/api/Message} wrapped inside of a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).

### 批量接收

Use `batchReceive` to receive multiple messages for each call.

The following is an example.

```java
Messages messages = consumer.batchReceive();
for (Object message : messages) {
  // do something
}
consumer.acknowledge(messages)
```

&gt; 注意：
&gt; 
&gt; 批量接收策略会限制每个批次中消息的数量和字节大小。可以指定一个超时时间以等待足够的消息。
&gt; 
&gt; 如果满足以下任一条件，则批量接收完成：足够的消息数量、足够的消息字节数、等待超时。
&gt; 
&gt; ```java
&gt; Consumer consumer = client.newConsumer()
&gt;         .topic(&quot;my-topic&quot;)
&gt;         .subscriptionName(&quot;my-subscription&quot;)
&gt;         .batchReceivePolicy(BatchReceivePolicy.builder()
&gt;              .maxNumMessages(100)
&gt;              .maxNumBytes(1024 * 1024)
&gt;              .timeout(200, TimeUnit.MILLISECONDS)
&gt;              .build())
&gt;         .subscribe();
&gt; ```
&gt; 
&gt; 默认批量接收策略是：
&gt; 
&gt; ```java
&gt; BatchReceivePolicy.builder()
&gt;     .maxNumMessage(-1)
&gt;     .maxNumBytes(10 * 1024 * 1024)
&gt;     .timeout(100, TimeUnit.MILLISECONDS)
&gt;     .build();
&gt; ```

### 否定确认重传退避

The `RedeliveryBackoff` introduces a redelivery backoff mechanism. You can achieve redelivery with different delays by setting `redeliveryCount` of messages.

```java
Consumer consumer =  client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .negativeAckRedeliveryBackoff(MultiplierRedeliveryBackoff.builder()
                .minDelayMs(1000)
                .maxDelayMs(60 * 1000)
                .build())
        .subscribe();
```

### Acknowledgement timeout redelivery backoff

The `RedeliveryBackoff` introduces a redelivery backoff mechanism. You can redeliver messages with different delays by setting the number of times the messages is retried.

```java
Consumer consumer =  client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .ackTimeout(10, TimeUnit.SECOND)
        .ackTimeoutRedeliveryBackoff(MultiplierRedeliveryBackoff.builder()
                .minDelayMs(1000)
                .maxDelayMs(60000)
                .multiplier(2)
                .build())
        .subscribe();
```

The message redelivery behavior should be as follows.

| Redelivery count | Redelivery delay |
|:---------------- |:---------------- |
| 1                | 10 + 1 seconds   |
| 2                | 10 + 2 seconds   |
| 3                | 10 + 4 seconds   |
| 4                | 10 + 8 seconds   |
| 5                | 10 + 16 seconds  |
| 6                | 10 + 32 seconds  |
| 7                | 10 + 60 seconds  |
| 8                | 10 + 60 seconds  |

&gt; **注意** - `negativeAckRedeliveryBackoff` 不适用于 `consumer.negativeAcknowledge(MessageId messageId)`，因为无法通过消息 ID 获取重传次数。 - 如果消费者崩溃，则会触发重传未确认的消息。 In this case, `RedeliveryBackoff` does not take effect and the messages might get redelivered earlier than the delay time from the backoff.

### 多主题订阅

消费者除了订阅单个Pulsar主题外，你还可以使用[多主题订阅](/docs/zh-CN/next/concepts-messaging#multi-topic-subscriptions)订阅多个主题。 若要使用多主题订阅, 可以提供一个topic正则表达式 (regex) 或 主题`List` 。 如果通过 regex 选择主题, 则所有主题都必须位于同一Pulsar命名空间中。

The followings are some examples.

```java
import org.apache.pulsar.client.api.Consumer;
import org.apache.pulsar.client.api.PulsarClient;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

ConsumerBuilder consumerBuilder = pulsarClient.newConsumer()
        .subscriptionName(subscription);

// Subscribe to all topics in a namespace
Pattern allTopicsInNamespace = Pattern.compile(&quot;public/default/.*&quot;);
Consumer allTopicsConsumer = consumerBuilder
        .topicsPattern(allTopicsInNamespace)
        .subscribe();

// Subscribe to a subsets of topics in a namespace, based on regex
Pattern someTopicsInNamespace = Pattern.compile(&quot;public/default/foo.*&quot;);
Consumer allTopicsConsumer = consumerBuilder
        .topicsPattern(someTopicsInNamespace)
        .subscribe();
```

In the above example, the consumer subscribes to the `persistent` topics that can match the topic name pattern. If you want the consumer subscribes to all `persistent` and `non-persistent` topics that can match the topic name pattern, set `subscriptionTopicsMode` to `RegexSubscriptionMode.AllTopics`.

```java
Pattern pattern = Pattern.compile(&quot;public/default/.*&quot;);
pulsarClient.newConsumer()
        .subscriptionName(&quot;my-sub&quot;)
        .topicsPattern(pattern)
        .subscriptionTopicsMode(RegexSubscriptionMode.AllTopics)
        .subscribe();
```

&gt; **注意**  
&gt; 默认情况下，消费者的 `subscriptionTopicsMode` 是 `PersistentOnly`。 `subscriptionTopicsMode` 的可用选项为： `PersistentOnly`，`NonPersistentOnly`，以及 `AllTopics`。

你还可以订阅明确的主题列表 (如果愿意, 可跨命名空间):

```java
List&lt;String&gt; topics = Arrays.asList(
        &quot;topic-1&quot;,
        &quot;topic-2&quot;,
        &quot;topic-3&quot;
);

Consumer multiTopicConsumer = consumerBuilder
        .topics(topics)
        .subscribe();

// Alternatively:
Consumer multiTopicConsumer = consumerBuilder
        .topic(
            &quot;topic-1&quot;,
            &quot;topic-2&quot;,
            &quot;topic-3&quot;
        )
        .subscribe();
```

You can also subscribe to multiple topics asynchronously using the `subscribeAsync` method rather than the synchronous `subscribe` method. The following is an example.

```java
Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default.*&quot;);
consumerBuilder
        .topics(topics)
        .subscribeAsync()
        .thenAccept(this::receiveMessageFromConsumer);

private void receiveMessageFromConsumer(Object consumer) {
    ((Consumer)consumer).receiveAsync().thenAccept(message -&gt; {
                // Do something with the received message
                receiveMessageFromConsumer(consumer);
            });
}
```

### Subscription types

Pulsar has various [subscription types](concepts-messaging#subscription-types) to match different scenarios. A topic can have multiple subscriptions with different subscription types. However, a subscription can only have one subscription type at a time.

A subscription is identical with the subscription name; a subscription name can specify only one subscription type at a time. To change the subscription type, you should first stop all consumers of this subscription.

Different subscription types have different message distribution types. This section describes the differences of subscription types and how to use them.

In order to better describe their differences, assuming you have a topic named &quot;my-topic&quot;, and the producer has published 10 messages.

```java
Producer&lt;String&gt; producer = client.newProducer(Schema.STRING)
        .topic(&quot;my-topic&quot;)
        .enableBatching(false)
        .create();
// 3 messages with &quot;key-1&quot;, 3 messages with &quot;key-2&quot;, 2 messages with &quot;key-3&quot; and 2 messages with &quot;key-4&quot;
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-1&quot;).send();
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-2&quot;).send();
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-3&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-1&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-2&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-3&quot;).send();
producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-1&quot;).send();
producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-2&quot;).send();
producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-1&quot;).send();
producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-2&quot;).send();
```

#### Exclusive

Create a new consumer and subscribe with the `Exclusive` subscription type.

```java
Consumer consumer = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Exclusive)
        .subscribe()
```

Only the first consumer is allowed to the subscription, other consumers receive an error. The first consumer receives all 10 messages, and the consuming order is the same as the producing order.

&gt; 注意：
&gt; 
&gt; 如果是分区主题，则第一个消费者订阅所有的分区主题，其他消费者不会被分配分区并会收到错误。

#### Failover（灾备）

Create new consumers and subscribe with the`Failover` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Failover)
        .subscribe()
Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Failover)
        .subscribe()
//conumser1 is the active consumer, consumer2 is the standby consumer.
//consumer1 receives 5 messages and then crashes, consumer2 takes over as an  active consumer.


```

Multiple consumers can attach to the same subscription, yet only the first consumer is active, and others are standby. When the active consumer is disconnected, messages will be dispatched to one of standby consumers, and the standby consumer then becomes active consumer.

If the first active consumer is disconnected after receiving 5 messages, the standby consumer becomes active consumer. Consumer1 will receive:

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    

consumer2 will receive:

    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

&gt; 注意：
&gt; 
&gt; 如果是分区主题，则每个分区只有一个活跃消费者， 一个分区的消息只分发给一个消费者，多个分区的消息分发给多个消费者。

#### Shared（共享）

Create new consumers and subscribe with `Shared` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Shared)
        .subscribe()

Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Shared)
        .subscribe()
//Both consumer1 and consumer 2 is active consumers.
```

In Shared subscription type, multiple consumers can attach to the same subscription and messages are delivered in a round robin distribution across consumers.

If a broker dispatches only one message at a time, consumer1 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    

consumer2 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

`Shared` subscription is different from `Exclusive` and `Failover` subscription types. `Shared` subscription has better flexibility, but cannot provide order guarantee.

#### Key_shared

This is a new subscription type since 2.4.0 release. Create new consumers and subscribe with `Key_Shared` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Key_Shared)
        .subscribe()

Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Key_Shared)
        .subscribe()
//Both consumer1 and consumer2 are active consumers.
```

Just like in `Shared` subscription, all consumers in `Key_Shared` subscription type can attach to the same subscription. But `Key_Shared` subscription type is different from the `Shared` subscription. In `Key_Shared` subscription type, messages with the same key are delivered to only one consumer in order. The possible distribution of messages between different consumers (by default we do not know in advance which keys will be assigned to a consumer, but a key will only be assigned to a consumer at the same time).

consumer1 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    

consumer2 receives the following information.

    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

If batching is enabled at the producer side, messages with different keys are added to a batch by default. The broker will dispatch the batch to the consumer, so the default batch mechanism may break the Key_Shared subscription guaranteed message distribution semantics. The producer needs to use the `KeyBasedBatcher`.

```java
Producer producer = client.newProducer()
        .topic(&quot;my-topic&quot;)
        .batcherBuilder(BatcherBuilder.KEY_BASED)
        .create();
```

Or the producer can disable batching.

```java
Producer producer = client.newProducer()
        .topic(&quot;my-topic&quot;)
        .enableBatching(false)
        .create();
```

&gt; 注意：
&gt; 
&gt; 如果未指定消息 key，则默认情况下无 key 的消息会按顺序分发给一个消费者。

## Reader

With the [reader interface](/docs/zh-CN/next/concepts-clients#reader-interface), Pulsar clients can &quot;manually position&quot; themselves within a topic and reading all messages from a specified message onward. The Pulsar API for Java enables you to create {@inject: javadoc:Reader:/client/org/apache/pulsar/client/api/Reader} objects by specifying a topic and a {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId}.

The following is an example.

```java
byte[] msgIdBytes = // Some message ID byte array
MessageId id = MessageId.fromByteArray(msgIdBytes);
Reader reader = pulsarClient.newReader()
        .topic(topic)
        .startMessageId(id)
        .create();

while (true) {
    Message message = reader.readNext();
    // Process message
}
```

In the example above, a `Reader` object is instantiated for a specific topic and message (by ID); the reader iterates over each message in the topic after the message is identified by `msgIdBytes` (how that value is obtained depends on the application).

上面的示例代码展示了`Reader`对象指向特定的消息(ID)，但你也可以使用`MessageId.earliest`来指向topic上最早可用的消息，使用`MessageId.latest`指向最新的消息。

### 配置读者

When you create a reader, you can use the `loadConf` configuration. The following parameters are available in `loadConf`.

| Name | Type|

&lt;div style=&quot;width:300px&quot;&gt;
  说明
&lt;/div&gt;
| Default |\---|\---|\---|\--- `topicName`|String|Topic name. |None `receiverQueueSize`|int|Size of a consumer's receiver queue.  
  
For example, the number of messages that can be accumulated by a consumer before an application calls ` `.  
  
A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.|1000 `readerListener`|ReaderListener&lt;T&gt;|A listener that is called for message received.|None `readerName`|String|Reader name.|null `subscriptionName`|String| Subscription name|When there is a single topic, the default subscription name is `&quot;reader-&quot; + 10-digit UUID`.  
When there are multiple topics, the default subscription name is `&quot;multiTopicsReader-&quot; + 10-digit UUID`. `subscriptionRolePrefix`|String|Prefix of subscription role. |null `cryptoKeyReader`|CryptoKeyReader|Interface that abstracts the access to a key store.|null `cryptoFailureAction`| ConsumerCryptoFailureAction | 当接收到无法解密的消息时，消费者应该采取的行动。  


* **FAIL**：这是在加密成功之前对于失败消息采取的默认选项。
* **DISCARD**: silently acknowledge and not deliver message to an application.
* **CONSUME**：向应用程序分发加密的消息。而由应用程序负责解密消息。
  
消息解压失败。   
  
如果消息包含批处理消息，则客户端无法在 batch 中检索单条消息。  
  
分发的加密消息包含 {@link EncryptionContext}，其中包含加密和压缩信息，应用程序可以利用这些信息解密消息载荷。| ConsumerCryptoFailureAction.FAIL&lt;/li&gt; `readCompacted`| boolean | 如果启用 `readCompacted`, a consumer reads messages from a compacted topic rather than a full message backlog of a topic.  
  
消费者只能看到压缩主题中每个 key 的最新值，直到压缩 backlog 时主题消息中对应的位点。 超过这一位点，消息照常发送。  
  
`readCompacted` can only be enabled on subscriptions to persistent topics, which have a single active consumer (for example, failure or exclusive subscriptions).   
  
如果试图在非持久化主题或者共享订阅上开启该功能，则会导致订阅调用抛出 `PulsarClientException`。|false `resetIncludeHead`|boolean|If set to true, the first message to be returned is the one specified by `messageId`.  
  
If set to false, the first message to be returned is the one next to the message specified by `messageId`。|false

### Sticky key range reader

In sticky key range reader, broker will only dispatch messages which hash of the message key contains by the specified key hash range. Multiple key hash ranges can be specified on a reader.

The following is an example to create a sticky key range reader.

```java
pulsarClient.newReader()
        .topic(topic)
        .startMessageId(MessageId.earliest)
        .keyHashRange(Range.of(0, 10000), Range.of(20001, 30000))
        .create();
```

Total hash range size is 65536, so the max end of the range should be less than or equal to 65535.

## TableView

The TableView interface serves an encapsulated access pattern, providing a continuously updated key-value map view of the compacted topic data. Messages without keys will be ignored.

With TableView, Pulsar clients can fetch all the message updates from a topic and construct a map with the latest values of each key. These values can then be used to build a local cache of data. In addition, you can register consumers with the TableView by specifying a listener to perform a scan of the map and then receive notifications when new messages are received. Consequently, event handling can be triggered to serve use cases, such as event-driven applications and message monitoring.

&gt; **Note:** Each TableView uses one Reader instance per partition, and reads the topic starting from the compacted view by default. It is highly recommended to enable automatic compaction by [configuring the topic compaction policies](/docs/zh-CN/next/cookbooks-compaction#configuring-compaction-to-run-automatically) for the given topic or namespace. More frequent compaction results in shorter startup times because less data is replayed to reconstruct the TableView of the topic.

The following figure illustrates the dynamic construction of a TableView updated with newer values of each key. ![TableView](/docs/assets/tableview.png)

### Configure TableView

The following is an example of how to configure a TableView.

    try (TableView&lt;String&gt; tv = client.newTableViewBuilder(Schema.STRING)
      .topic(&quot;tableview-test&quot;)
      .create()) {
        String value = tv.get(&quot;my-key&quot;);
        System.out.println(&quot;Key's value: &quot; + value);
    }
    

You can use the available parameters in the `loadConf` configuration or related [API](https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/2.10.0-SNAPSHOT/org/apache/pulsar/client/api/TableViewBuilder.html) to customize your TableView.

| Name | Type| Required? |

&lt;div style=&quot;width:300px&quot;&gt;
  说明
&lt;/div&gt;
| 默认值                                                                                                         |
| ----------------------------------------------------------------------------------------------------------- |
| `topic` | string | yes | The topic name of the TableView. | N/A                                             |
| `autoUpdatePartitionInterval` | int | no | The interval to check for newly added partitions. | 60 (seconds) |

## Schema

In Pulsar, all message data consists of byte arrays &quot;under the hood.&quot; [Message schemas](/docs/zh-CN/next/schema-get-started) enable you to use other types of data when constructing and handling messages (from simple types like strings to more complex, application-specific types). 如果在不指定 schema 的情况下构造 [生产者](#producer)，那么生产者只能生产 `byte[]` 类型的消息。 The following is an example.

```java
Producer&lt;byte[]&gt; producer = client.newProducer()
        .topic(topic)
        .create();
```

上面的生产者相当于 `Producer&lt;byte[]&gt;` (实际上, 你应该 *总是* 显式指定类型)。 如果你想让产生者使用不同类型的数据，你需要指定一个**schema**来通知Pulsar 在[topic](/docs/zh-CN/next/reference-terminology#topic)上传输哪种类型的数据。

### AvroBaseStructSchema example

假设您有一个 `SensorReading` 类, 你想通过Pulsar主题进行传输:

```java
public class SensorReading {
    public float temperature;

    public SensorReading(float temperature) {
        this.temperature = temperature;
    }

    // A no-arg constructor is required
    public SensorReading() {
    }

    public float getTemperature() {
        return temperature;
    }

    public void setTemperature(float temperature) {
        this.temperature = temperature;
    }
}
```

You could then create a `Producer&lt;SensorReading&gt;` (or `Consumer&lt;SensorReading&gt;`) like this:

```java
Producer&lt;SensorReading&gt; producer = client.newProducer(JSONSchema.of(SensorReading.class))
        .topic(&quot;sensor-readings&quot;)
        .create();
```

以下schema格式目前可用于 Java:

* 无schema 或者字节数组schema(可以使用`Schema.BYTES`)：
    
    ```java
    Producer&lt;byte[]&gt; bytesProducer = client.newProducer(Schema.BYTES)
        .topic(&quot;some-raw-bytes-topic&quot;)
        .create();
    ```
    
    或者:
    
    ```java
    Producer&lt;byte[]&gt; bytesProducer = client.newProducer()
        .topic(&quot;some-raw-bytes-topic&quot;)
        .create();
    ```

* 普通 UTF-8 编码字符串数据的 `String`。使用 `Schema.STRING` 应用该 schema：
    
    ```java
    Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(&quot;some-string-topic&quot;)
        .create();
    ```

* 使用 `Schema.JSON` 为 POJO 创建 JSON schema。下面是一个例子。
    
    ```java
    Producer&lt;MyPojo&gt; pojoProducer = client.newProducer(Schema.JSON(MyPojo.class))
        .topic(&quot;some-pojo-topic&quot;)
        .create();
    ```

* 使用 `Schema.PROTOBUF` 生成 Protobuf schema。 下面的示例演示如何创建 Protobuf schema，并用它来实例化一个新的生产者：
    
    ```java
    Producer&lt;MyProtobuf&gt; protobufProducer = client.newProducer(Schema.PROTOBUF(MyProtobuf.class))
        .topic(&quot;some-protobuf-topic&quot;)
        .create();
    ```

* 使用 `Schema.AVRO` 定义 Avro schema。下面的代码片段演示了如何创建和使用 Avro schema。
    
    ```java
    Producer&lt;MyAvro&gt; avroProducer = client.newProducer(Schema.AVRO(MyAvro.class))
        .topic(&quot;some-avro-topic&quot;)
        .create();
    ```

### ProtobufNativeSchema example

For example of ProtobufNativeSchema, see [`SchemaDefinition` in `Complex type`](/docs/zh-CN/next/schema-understand#complex-type).

## 认证

Pulsar currently supports three authentication schemes: [TLS](/docs/zh-CN/next/security-tls-authentication), [Athenz](/docs/zh-CN/next/security-athenz), and [Oauth2](/docs/zh-CN/next/security-oauth2). You can use the Pulsar Java client with all of them.

### TLS 认证

要使用[TLS](/docs/zh-CN/next/security-tls-authentication)，你需要使用`setUseTls`方法设置TLS为`true`，将您的Pulsar客户端指向TLS证书路径，并提供证书和密钥文件的路径。

The following is an example.

```java
Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
authParams.put(&quot;tlsCertFile&quot;, &quot;/path/to/client-cert.pem&quot;);
authParams.put(&quot;tlsKeyFile&quot;, &quot;/path/to/client-key.pem&quot;);

Authentication tlsAuth = AuthenticationFactory
        .create(AuthenticationTls.class.getName(), authParams);

PulsarClient client = PulsarClient.builder()
        .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
        .enableTls(true)
        .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
        .authentication(tlsAuth)
        .build();
```

### Athenz

要使用[Athenz](/docs/zh-CN/next/security-athenz)做为身份认证提供者，你需要[use TLS](#tls-authentication)并且在hash提供如下四个参数的值：

* `tenantDomain`
* `tenantService`
* `providerDomain`
* `privateKey`

You can also set an optional `keyId`. The following is an example.

```java
Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
authParams.put(&quot;tenantDomain&quot;, &quot;shopping&quot;); // Tenant domain name
authParams.put(&quot;tenantService&quot;, &quot;some_app&quot;); // Tenant service name
authParams.put(&quot;providerDomain&quot;, &quot;pulsar&quot;); // Provider domain name
authParams.put(&quot;privateKey&quot;, &quot;file:///path/to/private.pem&quot;); // Tenant private key path
authParams.put(&quot;keyId&quot;, &quot;v1&quot;); // Key id for the tenant private key (optional, default: &quot;0&quot;)

Authentication athenzAuth = AuthenticationFactory
        .create(AuthenticationAthenz.class.getName(), authParams);

PulsarClient client = PulsarClient.builder()
        .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
        .enableTls(true)
        .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
        .authentication(athenzAuth)
        .build();
```

&gt; #### 支持的格式：
&gt; 
&gt; `privateKey`参数支持如下三种格式： * `file:///path/to/file` * `file:/path/to/file` * `data:application/x-pem-file;base64,&lt;base64-encoded value&gt;`

### Oauth2

The following example shows how to use [Oauth2](/docs/zh-CN/next/security-oauth2) as an authentication provider for the Pulsar Java client.

你可以在 Pulsar Java 客户端中使用工厂方法配置身份认证操作。

```java
PulsarClient client = PulsarClient.builder()
    .serviceUrl(&quot;pulsar://broker.example.com:6650/&quot;)
    .authentication(
        AuthenticationFactoryOAuth2.clientCredentials(this.issuerUrl, this.credentialsUrl, this.audience))
    .build();
```

此外，你也可以在 Pulsar 客户端中使用编码参数来配置身份认证。

```java
Authentication auth = AuthenticationFactory
    .create(AuthenticationOAuth2.class.getName(), &quot;{&quot;type&quot;:&quot;client_credentials&quot;,&quot;privateKey&quot;:&quot;...&quot;,&quot;issuerUrl&quot;:&quot;...&quot;,&quot;audience&quot;:&quot;...&quot;}&quot;);
PulsarClient client = PulsarClient.builder()
    .serviceUrl(&quot;pulsar://broker.example.com:6650/&quot;)
    .authentication(auth)
    .build();
```</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/next/client-libraries"><span class="arrow-prev">← </span><span>概述</span></a><a class="docs-next button" href="/docs/zh-CN/next/client-libraries-go"><span>Go</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#安装">安装</a><ul class="toc-headings"><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ul></li><li><a href="#连接-url">连接 URL</a></li><li><a href="#client">Client</a><ul class="toc-headings"><li><a href="#默认的broker-url是单机集群">默认的broker URL是单机集群。</a></li><li><a href="#客户端内存分配器配置">客户端内存分配器配置</a></li></ul></li><li><a href="#生产者producer">生产者（Producer）</a><ul class="toc-headings"><li><a href="#配置producer生产者">配置Producer（生产者）</a></li><li><a href="#消息路由">消息路由</a></li><li><a href="#异步发送">异步发送</a></li><li><a href="#配置消息">配置消息</a></li></ul></li><li><a href="#消费者consumer">消费者（Consumer）</a><ul class="toc-headings"><li><a href="#配置消费者">配置消费者</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2022 The Apache Software Foundation. All Rights Reserved. Apache, Apache Pulsar and the Apache feather logo are trademarks of The Apache Software Foundation.</section><span><script>
      const community = document.querySelector("a[href='#community']").parentNode;
      const communityMenu =
        '<li>' +
        '<a id="community-menu" href="#">Community <span style="font-size: 0.75em">&nbsp;▼</span></a>' +
        '<div id="community-dropdown" class="hide">' +
          '<ul id="community-dropdown-items">' +
            '<li><a href="/zh-CN/contact">Contact</a></li>' +
            '<li><a href="/zh-CN/contributing">Contributing</a></li>' +
            '<li><a href="/zh-CN/coding-guide">Coding guide</a></li>' +
            '<li><a href="/zh-CN/events">Events</a></li>' +
            '<li><a href="https://twitter.com/Apache_Pulsar" target="_blank">Twitter &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/wiki" target="_blank">Wiki &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/issues" target="_blank">Issue tracking &#x2750</a></li>' +
            '<li><a href="https://pulsar-summit.org/" target="_blank">Pulsar Summit &#x2750</a></li>' +
            '<li>&nbsp;</li>' +
            '<li><a href="/zh-CN/resources">Resources</a></li>' +
            '<li><a href="/zh-CN/team">Team</a></li>' +
            '<li><a href="/zh-CN/powered-by">Powered By</a></li>' +
          '</ul>' +
        '</div>' +
        '</li>';

      community.innerHTML = communityMenu;

      const communityMenuItem = document.getElementById("community-menu");
      const communityDropDown = document.getElementById("community-dropdown");
      communityMenuItem.addEventListener("click", function(event) {
        event.preventDefault();

        if (communityDropDown.className == 'hide') {
          communityDropDown.className = 'visible';
        } else {
          communityDropDown.className = 'hide';
        }
      });
    </script></span></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'd226a455cecdd4bc18a554c1b47e5b52',
                indexName: 'apache_pulsar',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN","version:next"]}
              });
            </script></body></html>